% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: Mechanism
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef Mechanism < Indigo.Systems.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_g = 9.81;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = Mechanism( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 8;
      num_veil = 0;
      num_invs = 6;
      this = this@Indigo.Systems.Implicit('Mechanism', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_g = varargin{1}.g;
      elseif (nargin == 1)
        this.m_g = varargin{1};
      else
        error('wrong number of input arguments.');
      end
    end % Mechanism
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, in_3, t )
      % Evaluate the function F.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);
      x1_dot = in_2(1);
      y1_dot = in_2(2);
      x2_dot = in_2(3);
      u1_dot = in_2(4);
      v1_dot = in_2(5);
      u2_dot = in_2(6);
      lambda1_dot = in_2(7);
      lambda2_dot = in_2(8);

      % Evaluate function
      t2 = 2 * x1 - 2 * x2;
      out_1 = lambda2 * t2 + u2_dot;
      out_2 = y1_dot - v1;
      out_3 = x2_dot - u2;
      out_4 = -2 * lambda1 * x1 - lambda2 * t2 + u1_dot;
      t8 = -lambda1 - lambda2;
      out_5 = 2 * y1 * t8 + g + v1_dot;
      out_6 = x1_dot - u1;
      t11 = x1 ^ 2;
      t12 = y1 ^ 2;
      out_7 = -lambda1_dot * (t11 + t12) - lambda2_dot * (-x1 * x2 + t11 + t12) - 4 * ((u1 - u2 / 4) * x1 - 0.3e1 / 0.4e1 * u1 * x2 + v1 * y1) * lambda2 - 4 * u1 * x1 * lambda1 + v1 * (-8 * y1 * lambda1 + 3 * g) / 2;
      t36 = t11 ^ 2;
      t38 = t11 * x1;
      t41 = x2 ^ 2;
      t57 = u2 * lambda1;
      t65 = u1 * lambda1;
      out_8 = lambda2_dot * (2 * t36 - 4 * x2 * t38 + t11 * (2 * t41 + 2 * t12) - 4 * x2 * x1 * t12 + 4 * t41 * t12) / 2 + t38 * ((8 * u1 - 14 * u2) * lambda2 - 6 * t57) / 2 - t11 * ((u1 - 7 * u2) * lambda2 - 3 * t65) * x2 + x1 * (-6 * t41 * u1 * lambda2 - 3 * x2 * (0.8e1 / 0.3e1 * y1 * t8 + g) * v1 + 8 * ((u1 - 0.7e1 / 0.4e1 * u2) * lambda2 - 0.3e1 / 0.4e1 * t57) * t12) / 2 - 5 * x2 * ((u1 - 0.8e1 / 0.5e1 * u2) * lambda2 + t65 / 5) * t12;

      % Store outputs
      out_F = zeros(8, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
      out_F(6) = out_6;
      out_F(7) = out_7;
      out_F(8) = out_8;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);
      x1_dot = in_2(1);
      y1_dot = in_2(2);
      x2_dot = in_2(3);
      u1_dot = in_2(4);
      v1_dot = in_2(5);
      u2_dot = in_2(6);
      lambda1_dot = in_2(7);
      lambda2_dot = in_2(8);

      % Evaluate function
      out_1_1 = 2 * lambda2;
      t1 = -lambda1 - lambda2;
      out_4_1 = 2 * t1;
      t4 = 2 * x1;
      t8 = u1 - u2 / 4;
      t11 = u1 * lambda1;
      out_7_1 = -2 * x1 * lambda1_dot - lambda2_dot * (t4 - x2) - 4 * lambda2 * t8 - 4 * t11;
      t13 = x1 ^ 2;
      t14 = t13 * x1;
      t16 = x2 * t13;
      t18 = x2 ^ 2;
      t19 = y1 ^ 2;
      t24 = x2 * t19;
      t31 = 8 * u1 - 14 * u2;
      t33 = u2 * lambda1;
      t39 = u1 - 7 * u2;
      t42 = lambda2 * t39 - 3 * t11;
      t46 = lambda2 * u1;
      t49 = 0.8e1 / 0.3e1 * t1;
      t51 = y1 * t49 + g;
      t52 = t51 * v1;
      t56 = u1 - 0.7e1 / 0.4e1 * u2;
      t59 = lambda2 * t56 - 0.3e1 / 0.4e1 * t33;
      out_8_1 = lambda2_dot * (8 * t14 - 12 * t16 + 2 * x1 * (2 * t18 + 2 * t19) - 4 * t24) / 2 + 0.3e1 / 0.2e1 * t13 * (lambda2 * t31 - 6 * t33) - 2 * x1 * t42 * x2 - 3 * t18 * t46 - 0.3e1 / 0.2e1 * x2 * t52 + 4 * t59 * t19;
      out_5_2 = out_4_1;
      out_7_2 = -4 * lambda1 * v1 - 4 * lambda2 * v1 - 2 * y1 * lambda1_dot - 2 * y1 * lambda2_dot;
      t89 = u1 - 0.8e1 / 0.5e1 * u2;
      t92 = lambda2 * t89 + t11 / 5;
      out_8_2 = lambda2_dot * (-8 * x1 * x2 * y1 + 4 * y1 * t13 + 8 * y1 * t18) / 2 + x1 * (-3 * x2 * t49 * v1 + 16 * t59 * y1) / 2 - 10 * x2 * t92 * y1;
      out_1_3 = -out_1_1;
      out_4_3 = out_1_1;
      out_7_3 = x1 * lambda2_dot + 3 * t46;
      t107 = u1 * x2;
      out_8_3 = lambda2_dot * (-4 * t19 * x1 - 4 * t14 + 4 * t16 + 8 * t24) / 2 - t13 * t42 + x1 * (-12 * lambda2 * t107 - 3 * t52) / 2 - 5 * t92 * t19;
      out_6_4 = -1;
      out_7_4 = -4 * (x1 - 0.3e1 / 0.4e1 * x2) * lambda2 - 4 * lambda1 * x1;
      t129 = t19 * lambda2;
      out_8_4 = 4 * t14 * lambda2 - t13 * (lambda2 - 3 * lambda1) * x2 + x1 * (-6 * t18 * lambda2 + 8 * t129) / 2 - 5 * x2 * (lambda2 + lambda1 / 5) * t19;
      out_2_5 = -1;
      out_7_5 = -4 * y1 * lambda2 - 4 * y1 * lambda1 + 0.3e1 / 0.2e1 * g;
      out_8_5 = -0.3e1 / 0.2e1 * x1 * x2 * t51;
      out_3_6 = -1;
      out_7_6 = lambda2 * x1;
      out_8_6 = t14 * (-14 * lambda2 - 6 * lambda1) / 2 + 7 * t13 * lambda2 * x2 + 4 * x1 * (-0.7e1 / 0.4e1 * lambda2 - 0.3e1 / 0.4e1 * lambda1) * t19 + 8 * x2 * t129;
      out_4_7 = -t4;
      out_5_7 = -2 * y1;
      t165 = v1 * y1;
      out_7_7 = -4 * u1 * x1 - 4 * t165;
      t175 = 8 * v1 * x2 * y1;
      out_8_7 = -3 * t14 * u2 + 3 * t13 * t107 + x1 * (-6 * t19 * u2 + t175) / 2 - x2 * u1 * t19;
      out_1_8 = 2 * x1 - 2 * x2;
      out_4_8 = -out_1_8;
      out_5_8 = out_5_7;
      out_7_8 = -4 * x1 * t8 + 3 * t107 - 4 * t165;
      out_8_8 = t14 * t31 / 2 - t13 * t39 * x2 + x1 * (-6 * t18 * u1 + 8 * t56 * t19 + t175) / 2 - 5 * x2 * t89 * t19;

      % Store outputs
      out_JF_x = zeros(8, 8);
      out_JF_x(1, 1) = out_1_1;
      out_JF_x(4, 1) = out_4_1;
      out_JF_x(7, 1) = out_7_1;
      out_JF_x(8, 1) = out_8_1;
      out_JF_x(5, 2) = out_5_2;
      out_JF_x(7, 2) = out_7_2;
      out_JF_x(8, 2) = out_8_2;
      out_JF_x(1, 3) = out_1_3;
      out_JF_x(4, 3) = out_4_3;
      out_JF_x(7, 3) = out_7_3;
      out_JF_x(8, 3) = out_8_3;
      out_JF_x(6, 4) = out_6_4;
      out_JF_x(7, 4) = out_7_4;
      out_JF_x(8, 4) = out_8_4;
      out_JF_x(2, 5) = out_2_5;
      out_JF_x(7, 5) = out_7_5;
      out_JF_x(8, 5) = out_8_5;
      out_JF_x(3, 6) = out_3_6;
      out_JF_x(7, 6) = out_7_6;
      out_JF_x(8, 6) = out_8_6;
      out_JF_x(4, 7) = out_4_7;
      out_JF_x(5, 7) = out_5_7;
      out_JF_x(7, 7) = out_7_7;
      out_JF_x(8, 7) = out_8_7;
      out_JF_x(1, 8) = out_1_8;
      out_JF_x(4, 8) = out_4_8;
      out_JF_x(5, 8) = out_5_8;
      out_JF_x(7, 8) = out_7_8;
      out_JF_x(8, 8) = out_8_8;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);
      x1_dot = in_2(1);
      y1_dot = in_2(2);
      x2_dot = in_2(3);
      u1_dot = in_2(4);
      v1_dot = in_2(5);
      u2_dot = in_2(6);
      lambda1_dot = in_2(7);
      lambda2_dot = in_2(8);

      % Evaluate function
      out_6_1 = 1;
      out_2_2 = 1;
      out_3_3 = 1;
      out_4_4 = 1;
      out_5_5 = 1;
      out_1_6 = 1;
      t1 = x1 ^ 2;
      t2 = y1 ^ 2;
      out_7_7 = -t1 - t2;
      out_7_8 = x1 * x2 - t1 - t2;
      t4 = t1 ^ 2;
      t8 = x2 ^ 2;
      out_8_8 = t4 - 2 * x2 * t1 * x1 + t1 * (2 * t8 + 2 * t2) / 2 - 2 * x2 * x1 * t2 + 2 * t8 * t2;

      % Store outputs
      out_JF_x_dot = zeros(8, 8);
      out_JF_x_dot(6, 1) = out_6_1;
      out_JF_x_dot(2, 2) = out_2_2;
      out_JF_x_dot(3, 3) = out_3_3;
      out_JF_x_dot(4, 4) = out_4_4;
      out_JF_x_dot(5, 5) = out_5_5;
      out_JF_x_dot(1, 6) = out_1_6;
      out_JF_x_dot(7, 7) = out_7_7;
      out_JF_x_dot(7, 8) = out_7_8;
      out_JF_x_dot(8, 8) = out_8_8;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);
      x1_dot = in_2(1);
      y1_dot = in_2(2);
      x2_dot = in_2(3);
      u1_dot = in_2(4);
      v1_dot = in_2(5);
      u2_dot = in_2(6);
      lambda1_dot = in_2(7);
      lambda2_dot = in_2(8);

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(8, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 8);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);

      % Evaluate function
      t1 = x1 ^ 2;
      t2 = y1 ^ 2;
      out_1 = -t1 - t2 + 1;
      t3 = x1 * x2;
      t5 = x2 ^ 2;
      out_2 = -t1 + 2 * t3 - t5 - t2 + 1;
      t7 = v1 * y1;
      out_3 = u1 * x1 + t7;
      t8 = x1 - x2;
      out_4 = u1 * t8 - u2 * t8 + t7;
      t16 = 2 * lambda1 * t1;
      t18 = 2 * lambda1 * t2;
      t19 = y1 * g;
      t20 = u1 ^ 2;
      t21 = v1 ^ 2;
      out_5 = lambda2 * (-2 * t1 + 2 * t3 - 2 * t2) - t16 - t18 + t19 - t20 - t21;
      t32 = u2 ^ 2;
      out_6 = lambda2 * (-4 * t1 + 8 * t3 - 4 * t5 - 2 * t2) - t16 + 2 * lambda1 * t3 - t18 + t19 - t20 + 2 * u2 * u1 - t32 - t21;

      % Store outputs
      out_h = zeros(6, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);

      % Evaluate function
      out_1_1 = -2 * x1;
      t2 = x2 - x1;
      out_2_1 = 2 * t2;
      out_3_1 = u1;
      out_4_1 = u1 - u2;
      t7 = lambda1 * x1;
      t8 = 4 * t7;
      out_5_1 = (-4 * x1 + 2 * x2) * lambda2 - t8;
      t9 = 8 * t2;
      out_6_1 = 2 * x2 * lambda1 + lambda2 * t9 - t8;
      out_1_2 = -2 * y1;
      out_2_2 = out_1_2;
      out_3_2 = v1;
      out_4_2 = v1;
      out_5_2 = -4 * y1 * lambda1 - 4 * y1 * lambda2 + g;
      out_6_2 = out_5_2;
      out_2_3 = -out_2_1;
      out_4_3 = -out_4_1;
      out_5_3 = 2 * lambda2 * x1;
      out_6_3 = -lambda2 * t9 + 2 * t7;
      out_3_4 = x1;
      out_4_4 = -t2;
      out_5_4 = -2 * u1;
      out_6_4 = 2 * out_4_3;
      out_3_5 = y1;
      out_4_5 = y1;
      out_5_5 = -2 * v1;
      out_6_5 = out_5_5;
      out_4_6 = t2;
      out_6_6 = -out_6_4;
      t24 = x1 ^ 2;
      t25 = y1 ^ 2;
      out_5_7 = -2 * t24 - 2 * t25;
      t27 = x1 * x2;
      out_6_7 = -2 * t24 + 2 * t27 - 2 * t25;
      out_5_8 = out_6_7;
      t31 = x2 ^ 2;
      out_6_8 = -4 * t24 + 8 * t27 - 4 * t31 - 2 * t25;

      % Store outputs
      out_Jh_x = zeros(6, 8);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 1) = out_2_1;
      out_Jh_x(3, 1) = out_3_1;
      out_Jh_x(4, 1) = out_4_1;
      out_Jh_x(5, 1) = out_5_1;
      out_Jh_x(6, 1) = out_6_1;
      out_Jh_x(1, 2) = out_1_2;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(3, 2) = out_3_2;
      out_Jh_x(4, 2) = out_4_2;
      out_Jh_x(5, 2) = out_5_2;
      out_Jh_x(6, 2) = out_6_2;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(4, 3) = out_4_3;
      out_Jh_x(5, 3) = out_5_3;
      out_Jh_x(6, 3) = out_6_3;
      out_Jh_x(3, 4) = out_3_4;
      out_Jh_x(4, 4) = out_4_4;
      out_Jh_x(5, 4) = out_5_4;
      out_Jh_x(6, 4) = out_6_4;
      out_Jh_x(3, 5) = out_3_5;
      out_Jh_x(4, 5) = out_4_5;
      out_Jh_x(5, 5) = out_5_5;
      out_Jh_x(6, 5) = out_6_5;
      out_Jh_x(4, 6) = out_4_6;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(5, 7) = out_5_7;
      out_Jh_x(6, 7) = out_6_7;
      out_Jh_x(5, 8) = out_5_8;
      out_Jh_x(6, 8) = out_6_8;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      g = this.m_g;

      % Extract inputs
      x1 = in_1(1);
      y1 = in_1(2);
      x2 = in_1(3);
      u1 = in_1(4);
      v1 = in_1(5);
      u2 = in_1(6);
      lambda1 = in_1(7);
      lambda2 = in_1(8);

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(6, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % Mechanism

% That's All Folks!
