% +--------------------------------------------------------------------------+
% | 'Indigo' module version 1.0 - BSD 3-Clause License - Copyright (c) 2023  |
% | Current version authors:                                                 |
% |   Davide Stocco and Enrico Bertolazzi.                                   |
% +--------------------------------------------------------------------------+

% Matlab generated code for implicit system: DoublePendulum
% This file has been automatically generated by Indigo.
% DISCLAIMER: If you need to edit it, do it wisely!

classdef DoublePendulum < Indigo.Systems.Implicit
  %
  % No class description provided.
  %
  properties (SetAccess = protected, Hidden = true)
    % User data
    m_m__1 = 1.0;
    m_m__2 = 1.0;
    m_g = 9.81;
    m_ell__1 = 1.0;
    m_ell__2 = 1.0;
  end
  %
  methods
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function this = DoublePendulum( varargin )
      % Class constructor.

      % Superclass constructor
      num_eqns = 10;
      num_veil = 0;
      num_invs = 6;
      this = this@Indigo.Systems.Implicit('DoublePendulum', num_eqns, num_veil, num_invs);

      % User data
      if (nargin == 0)
        % Keep default values
      elseif (nargin == 1 && isstruct(varargin{1}))
        this.m_m__1 = varargin{1}.m__1;
        this.m_m__2 = varargin{1}.m__2;
        this.m_g = varargin{1}.g;
        this.m_ell__1 = varargin{1}.ell__1;
        this.m_ell__2 = varargin{1}.ell__2;
      elseif (nargin == 5)
        this.m_m__1 = varargin{1};
        this.m_m__2 = varargin{2};
        this.m_g = varargin{3};
        this.m_ell__1 = varargin{4};
        this.m_ell__2 = varargin{5};
      else
        error('wrong number of input arguments.');
      end
    end % DoublePendulum
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_F = F( this, in_1, in_2, in_3, t )
      % Evaluate the function F.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);
      x__1_dot = in_2(1);
      y__1_dot = in_2(2);
      x__2_dot = in_2(3);
      y__2_dot = in_2(4);
      u__1_dot = in_2(5);
      v__1_dot = in_2(6);
      u__2_dot = in_2(7);
      v__2_dot = in_2(8);
      lambda__1_dot = in_2(9);
      lambda__2_dot = in_2(10);

      % Evaluate function
      out_1 = x__2_dot - u__2;
      out_2 = y__2_dot - v__2;
      t2 = 0.1e1 / m__1;
      t3 = t2 / m__2;
      t10 = lambda__1 * x__1;
      out_3 = (u__2_dot * m__2 * m__1 + 2 * m__1 * (x__2 + x__1) * lambda__2 - 2 * m__2 * t10) * t3;
      t20 = y__1 * lambda__1;
      out_4 = (v__2_dot * m__2 * m__1 + 2 * m__1 * (y__2 + y__1) * lambda__2 - 2 * m__2 * t20) * t3;
      out_5 = -2 * t2 * t10 - u__1_dot;
      t26 = g * m__1;
      out_6 = -v__1_dot + t2 * (-t26 - 2 * t20);
      out_7 = x__1_dot - u__1;
      t30 = x__1 ^ 2;
      t31 = y__1 ^ 2;
      t32 = -t30 - t31;
      out_8 = t2 * (2 * lambda__1_dot * t32 + y__1_dot * (-t26 - 4 * t20) + (-8 * u__1 * x__1 - 4 * v__1 * y__1) * lambda__1 - 2 * v__1 * g * m__1);
      t48 = -t32;
      out_9 = 2 * t2 * (y__1_dot - v__1) * t48;
      t52 = t48 ^ 2;
      t56 = y__2 ^ 2;
      t61 = x__2 ^ 2;
      t66 = 0.8e1 / 0.3e1 * u__1 + 0.8e1 / 0.3e1 * u__2;
      t68 = v__1 + v__2;
      out_10 = 0.3e1 / 0.2e1 * (lambda__2_dot * (0.2e1 / 0.3e1 * t31 + 0.4e1 / 0.3e1 * y__2 * y__1 + 0.2e1 / 0.3e1 * t56 + 0.2e1 / 0.3e1 * t30 + 0.4e1 / 0.3e1 * x__2 * x__1 + 0.2e1 / 0.3e1 * t61) + lambda__2 * (x__1 * t66 + 0.8e1 / 0.3e1 * y__1 * t68 + x__2 * t66 + 0.8e1 / 0.3e1 * t68 * y__2) + t68 * m__2 * g) * t52;

      % Store outputs
      out_F = zeros(10, 1);
      out_F(1) = out_1;
      out_F(2) = out_2;
      out_F(3) = out_3;
      out_F(4) = out_4;
      out_F(5) = out_5;
      out_F(6) = out_6;
      out_F(7) = out_7;
      out_F(8) = out_8;
      out_F(9) = out_9;
      out_F(10) = out_10;
    end % F
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x = JF_x( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);
      x__1_dot = in_2(1);
      y__1_dot = in_2(2);
      x__2_dot = in_2(3);
      y__2_dot = in_2(4);
      u__1_dot = in_2(5);
      v__1_dot = in_2(6);
      u__2_dot = in_2(7);
      v__2_dot = in_2(8);
      lambda__1_dot = in_2(9);
      lambda__2_dot = in_2(10);

      % Evaluate function
      t1 = 0.1e1 / m__2;
      t2 = 0.1e1 / m__1;
      out_3_1 = (2 * m__1 * lambda__2 - 2 * lambda__1 * m__2) * t2 * t1;
      out_5_1 = -2 * t2 * lambda__1;
      out_8_1 = t2 * (-8 * u__1 * lambda__1 - 4 * x__1 * lambda__1_dot);
      t15 = y__1_dot - v__1;
      out_9_1 = 4 * t2 * t15 * x__1;
      t18 = x__1 ^ 2;
      t19 = y__1 ^ 2;
      t20 = t18 + t19;
      t24 = y__2 ^ 2;
      t29 = x__2 ^ 2;
      t34 = 0.8e1 / 0.3e1 * u__1 + 0.8e1 / 0.3e1 * u__2;
      t36 = v__1 + v__2;
      t37 = 0.8e1 / 0.3e1 * t36;
      t42 = x__1 * t34 + y__1 * t37 + x__2 * t34 + 0.8e1 / 0.3e1 * t36 * y__2;
      t44 = g * m__2;
      t47 = (lambda__2_dot * (0.2e1 / 0.3e1 * t19 + 0.4e1 / 0.3e1 * y__2 * y__1 + 0.2e1 / 0.3e1 * t24 + 0.2e1 / 0.3e1 * t18 + 0.4e1 / 0.3e1 * x__2 * x__1 + 0.2e1 / 0.3e1 * t29) + lambda__2 * t42 + t36 * t44) * t20;
      t50 = t20 ^ 2;
      t51 = x__2 + x__1;
      t57 = 0.3e1 / 0.2e1 * (0.4e1 / 0.3e1 * lambda__2_dot * t51 + lambda__2 * t34) * t50;
      out_10_1 = 6 * x__1 * t47 + t57;
      out_4_2 = out_3_1;
      out_6_2 = out_5_1;
      out_8_2 = t2 * (-4 * v__1 * lambda__1 - 4 * y__1 * lambda__1_dot - 4 * lambda__1 * y__1_dot);
      out_9_2 = 4 * t2 * t15 * y__1;
      t67 = y__2 + y__1;
      t73 = 0.3e1 / 0.2e1 * (0.4e1 / 0.3e1 * lambda__2_dot * t67 + lambda__2 * t37) * t50;
      out_10_2 = 6 * y__1 * t47 + t73;
      out_3_3 = 2 * lambda__2 * t1;
      out_10_3 = t57;
      out_4_4 = out_3_3;
      out_10_4 = t73;
      out_7_5 = -1;
      out_8_5 = -8 * t2 * lambda__1 * x__1;
      out_10_5 = 4 * lambda__2 * t51 * t50;
      out_8_6 = t2 * (-2 * g * m__1 - 4 * y__1 * lambda__1);
      out_9_6 = -2 * t2 * t20;
      out_10_6 = 0.3e1 / 0.2e1 * (0.8e1 / 0.3e1 * lambda__2 * t67 + t44) * t50;
      out_1_7 = -1;
      out_10_7 = out_10_5;
      out_2_8 = -1;
      out_10_8 = out_10_6;
      out_3_9 = -2 * x__1 * t2;
      out_4_9 = -2 * y__1 * t2;
      out_5_9 = out_3_9;
      out_6_9 = out_4_9;
      out_8_9 = t2 * (-8 * u__1 * x__1 - 4 * v__1 * y__1 - 4 * y__1 * y__1_dot);
      out_3_10 = 2 * t51 * t1;
      out_4_10 = 2 * t67 * t1;
      out_10_10 = 0.3e1 / 0.2e1 * t42 * t50;

      % Store outputs
      out_JF_x = zeros(10, 10);
      out_JF_x(3, 1) = out_3_1;
      out_JF_x(5, 1) = out_5_1;
      out_JF_x(8, 1) = out_8_1;
      out_JF_x(9, 1) = out_9_1;
      out_JF_x(10, 1) = out_10_1;
      out_JF_x(4, 2) = out_4_2;
      out_JF_x(6, 2) = out_6_2;
      out_JF_x(8, 2) = out_8_2;
      out_JF_x(9, 2) = out_9_2;
      out_JF_x(10, 2) = out_10_2;
      out_JF_x(3, 3) = out_3_3;
      out_JF_x(10, 3) = out_10_3;
      out_JF_x(4, 4) = out_4_4;
      out_JF_x(10, 4) = out_10_4;
      out_JF_x(7, 5) = out_7_5;
      out_JF_x(8, 5) = out_8_5;
      out_JF_x(10, 5) = out_10_5;
      out_JF_x(8, 6) = out_8_6;
      out_JF_x(9, 6) = out_9_6;
      out_JF_x(10, 6) = out_10_6;
      out_JF_x(1, 7) = out_1_7;
      out_JF_x(10, 7) = out_10_7;
      out_JF_x(2, 8) = out_2_8;
      out_JF_x(10, 8) = out_10_8;
      out_JF_x(3, 9) = out_3_9;
      out_JF_x(4, 9) = out_4_9;
      out_JF_x(5, 9) = out_5_9;
      out_JF_x(6, 9) = out_6_9;
      out_JF_x(8, 9) = out_8_9;
      out_JF_x(3, 10) = out_3_10;
      out_JF_x(4, 10) = out_4_10;
      out_JF_x(10, 10) = out_10_10;
    end % JF_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_x_dot = JF_x_dot( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to x_dot.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);
      x__1_dot = in_2(1);
      y__1_dot = in_2(2);
      x__2_dot = in_2(3);
      y__2_dot = in_2(4);
      u__1_dot = in_2(5);
      v__1_dot = in_2(6);
      u__2_dot = in_2(7);
      v__2_dot = in_2(8);
      lambda__1_dot = in_2(9);
      lambda__2_dot = in_2(10);

      % Evaluate function
      out_7_1 = 1;
      t5 = 0.1e1 / m__1;
      out_8_2 = t5 * (-g * m__1 - 4 * y__1 * lambda__1);
      t6 = x__1 ^ 2;
      t7 = y__1 ^ 2;
      t8 = t6 + t7;
      out_9_2 = 2 * t5 * t8;
      out_1_3 = 1;
      out_2_4 = 1;
      out_5_5 = -1;
      out_6_6 = -1;
      out_3_7 = 1;
      out_4_8 = 1;
      out_8_9 = -2 * t5 * t8;
      t12 = t8 ^ 2;
      t16 = y__2 ^ 2;
      t21 = x__2 ^ 2;
      out_10_10 = 0.3e1 / 0.2e1 * (0.2e1 / 0.3e1 * t7 + 0.4e1 / 0.3e1 * y__2 * y__1 + 0.2e1 / 0.3e1 * t16 + 0.2e1 / 0.3e1 * t6 + 0.4e1 / 0.3e1 * x__2 * x__1 + 0.2e1 / 0.3e1 * t21) * t12;

      % Store outputs
      out_JF_x_dot = zeros(10, 10);
      out_JF_x_dot(7, 1) = out_7_1;
      out_JF_x_dot(8, 2) = out_8_2;
      out_JF_x_dot(9, 2) = out_9_2;
      out_JF_x_dot(1, 3) = out_1_3;
      out_JF_x_dot(2, 4) = out_2_4;
      out_JF_x_dot(5, 5) = out_5_5;
      out_JF_x_dot(6, 6) = out_6_6;
      out_JF_x_dot(3, 7) = out_3_7;
      out_JF_x_dot(4, 8) = out_4_8;
      out_JF_x_dot(8, 9) = out_8_9;
      out_JF_x_dot(10, 10) = out_10_10;
    end % JF_x_dot
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_JF_v = JF_v( this, in_1, in_2, in_3, t )
      % Evaluate the Jacobian of F with respect to v.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);
      x__1_dot = in_2(1);
      y__1_dot = in_2(2);
      x__2_dot = in_2(3);
      y__2_dot = in_2(4);
      u__1_dot = in_2(5);
      v__1_dot = in_2(6);
      u__2_dot = in_2(7);
      v__2_dot = in_2(8);
      lambda__1_dot = in_2(9);
      lambda__2_dot = in_2(10);

      % Evaluate function
      % No body

      % Store outputs
      out_JF_v = zeros(10, 0);
    end % JF_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_v = v( this, in_1, t )
      % Evaluate the the veils v.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);

      % Evaluate function
      % No body

      % Store outputs
      out_v = zeros(0, 1);
    end % v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jv_x = Jv_x( this, in_1, in_2, t )
      % Evaluate the Jacobian of v with respect to x.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);

      % Evaluate function
      % No body

      % Store outputs
      out_Jv_x = zeros(0, 10);
    end % Jv_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_h = h( this, in_1, in_2, t )
      % Calculate the residual of the invariants h.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);

      % Evaluate function
      t1 = ell__1 ^ 2;
      t2 = x__1 ^ 2;
      t3 = y__1 ^ 2;
      out_1 = -t1 + t2 + t3;
      t4 = ell__2 ^ 2;
      t7 = x__2 ^ 2;
      t8 = y__2 * y__1;
      t10 = y__2 ^ 2;
      out_2 = 2 * x__2 * x__1 + t10 + t2 + t3 - t4 + t7 + 2 * t8;
      out_3 = -u__1 * x__1 - v__1 * y__1;
      t13 = -x__2 - x__1;
      t17 = v__1 + v__2;
      out_4 = u__1 * t13 + u__2 * t13 - t17 * (y__2 + y__1);
      t22 = g * y__1;
      t23 = u__1 ^ 2;
      t24 = v__1 ^ 2;
      out_5 = 0.1e1 / m__1 * (lambda__1 * (-2 * t2 - 2 * t3) - (t22 - t23 - t24) * m__1);
      t33 = t13 ^ 2;
      t40 = u__2 ^ 2;
      t41 = t17 ^ 2;
      out_6 = 0.1e1 / m__2 * (lambda__2 * (-2 * t3 - 4 * t8 - 2 * t10 - 2 * t33) - (g * y__2 - 2 * u__2 * u__1 + t22 - t23 - t40 - t41) * m__2);

      % Store outputs
      out_h = zeros(6, 1);
      out_h(1) = out_1;
      out_h(2) = out_2;
      out_h(3) = out_3;
      out_h(4) = out_4;
      out_h(5) = out_5;
      out_h(6) = out_6;
    end % h
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_x = Jh_x( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to x.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);

      % Evaluate function
      out_1_1 = 2 * x__1;
      t1 = x__2 + x__1;
      out_2_1 = 2 * t1;
      out_3_1 = -u__1;
      out_4_1 = out_3_1 - u__2;
      t3 = 0.1e1 / m__1;
      out_5_1 = -4 * t3 * lambda__1 * x__1;
      t6 = -t1;
      t9 = 0.1e1 / m__2;
      out_6_1 = 4 * t9 * lambda__2 * t6;
      out_1_2 = 2 * y__1;
      t10 = y__2 + y__1;
      out_2_2 = 2 * t10;
      out_3_2 = -v__1;
      out_4_2 = out_3_2 - v__2;
      out_5_2 = t3 * (-g * m__1 - 4 * y__1 * lambda__1);
      t15 = -t10;
      out_6_2 = t9 * (-g * m__2 + 4 * lambda__2 * t15);
      out_2_3 = out_2_1;
      out_4_3 = out_4_1;
      out_6_3 = out_6_1;
      out_2_4 = out_2_2;
      out_4_4 = out_4_2;
      out_6_4 = out_6_2;
      out_3_5 = -x__1;
      out_4_5 = t6;
      out_5_5 = 2 * u__1;
      out_6_5 = -2 * out_4_3;
      out_3_6 = -y__1;
      out_4_6 = t15;
      out_5_6 = 2 * v__1;
      out_6_6 = -2 * out_4_4;
      out_4_7 = out_4_5;
      out_6_7 = out_6_5;
      out_4_8 = out_4_6;
      out_6_8 = out_6_6;
      t22 = x__1 ^ 2;
      t23 = y__1 ^ 2;
      out_5_9 = t3 * (-2 * t22 - 2 * t23);
      t29 = y__2 ^ 2;
      t31 = t1 ^ 2;
      out_6_10 = t9 * (-4 * y__2 * y__1 - 2 * t23 - 2 * t29 - 2 * t31);

      % Store outputs
      out_Jh_x = zeros(6, 10);
      out_Jh_x(1, 1) = out_1_1;
      out_Jh_x(2, 1) = out_2_1;
      out_Jh_x(3, 1) = out_3_1;
      out_Jh_x(4, 1) = out_4_1;
      out_Jh_x(5, 1) = out_5_1;
      out_Jh_x(6, 1) = out_6_1;
      out_Jh_x(1, 2) = out_1_2;
      out_Jh_x(2, 2) = out_2_2;
      out_Jh_x(3, 2) = out_3_2;
      out_Jh_x(4, 2) = out_4_2;
      out_Jh_x(5, 2) = out_5_2;
      out_Jh_x(6, 2) = out_6_2;
      out_Jh_x(2, 3) = out_2_3;
      out_Jh_x(4, 3) = out_4_3;
      out_Jh_x(6, 3) = out_6_3;
      out_Jh_x(2, 4) = out_2_4;
      out_Jh_x(4, 4) = out_4_4;
      out_Jh_x(6, 4) = out_6_4;
      out_Jh_x(3, 5) = out_3_5;
      out_Jh_x(4, 5) = out_4_5;
      out_Jh_x(5, 5) = out_5_5;
      out_Jh_x(6, 5) = out_6_5;
      out_Jh_x(3, 6) = out_3_6;
      out_Jh_x(4, 6) = out_4_6;
      out_Jh_x(5, 6) = out_5_6;
      out_Jh_x(6, 6) = out_6_6;
      out_Jh_x(4, 7) = out_4_7;
      out_Jh_x(6, 7) = out_6_7;
      out_Jh_x(4, 8) = out_4_8;
      out_Jh_x(6, 8) = out_6_8;
      out_Jh_x(5, 9) = out_5_9;
      out_Jh_x(6, 10) = out_6_10;
    end % Jh_x
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
    function out_Jh_v = Jh_v( this, in_1, in_2, t )
      % Calculate the Jacobian of h with respect to v.

      % Extract properties
      m__1 = this.m_m__1;
      m__2 = this.m_m__2;
      g = this.m_g;
      ell__1 = this.m_ell__1;
      ell__2 = this.m_ell__2;

      % Extract inputs
      x__1 = in_1(1);
      y__1 = in_1(2);
      x__2 = in_1(3);
      y__2 = in_1(4);
      u__1 = in_1(5);
      v__1 = in_1(6);
      u__2 = in_1(7);
      v__2 = in_1(8);
      lambda__1 = in_1(9);
      lambda__2 = in_1(10);

      % Evaluate function
      % No body

      % Store outputs
      out_Jh_v = zeros(6, 0);
    end % Jh_v
    %
    % - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    %
  end
end % DoublePendulum

% That's All Folks!
